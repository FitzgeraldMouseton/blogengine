/**
 * Spring Security - это гибко кастомизируемый фреймворк, разрабатываемый с 2003 года. Позволяет настраивать
 * аутентификацию (проверка существования пользователя в системе) и авторизацию (проверка прав пользователя
 * на доступ к различным ресурсам, операциям и т.д..)
 *
 * 1) Аутентификация. В Spring Security имеется класс Authentication, в котором имеется ссылка на Principal -
 * представление пользователя в системе. После аут-и Principal сохраняется в текущей сессии, а номер сессии
 * отправляется клиенту (браузеру) в виде cookies, после чего в каждый новый запрос клиента к серверу будут
 * добавляться эти куки для того, чтобы не аут-ся каждый раз заново.
 *
 * Web Server управляет контейнерами сервлетов, сервлеты обрабатывают http-запросы. При настройке Spring приложения
 * мы, среди проченего, настраиваем специальный DispatcherServlet, который "прерывают" (intercept) все запросы.
 * Перед сервлетами сидят фильтры, которые в свою очередь также прерывают запросы. Одним из таких фильтров при настройке
 * Spring Security является DelegatingFilterProxy. Далее запрос передается в FilterChainProxy, который направляет
 * запрос на какую-то цепочку фильров. Цепочки фильтров могут быть различными для разных типов запросов.
 * В них также можно вносить изменения. (рис. 1,2)
 * Итак, процесс аут-и выглядит слудующим образом (рис. 3) -
 * - Запрос обрабатывается одним из существующих фильтров (зависит от настроек прложения)
 * - Создается соответствующий объект Authentication, содержащий данные о пользователе
 * - Запрос перелается в AuthenticationManager
 * - AuthenticationManager передает запрос конкретному AuthenticationProvider (рис. 4)
 * - В случае устпешной аут-и AuthenticationProvider вернет AuthenticatedPrinciple, а AuthenticationFilter
 * сохранит его в SecurityContext (рис. 5)
 *
 * Виды аут-и:
 * - Form auth-n - аутентификация при помощи вводимых в форму логина и пароля, передаваемых в теле запроса
 * - Basic auth-n - пароль и логин передаются в следующем виде - username:password. Может передаваться в
 * хэдере("Authorization: Basic {username:password Base64 encoded}") или url(deprecated in RFC 3986)
 *
 * а) Добавляем зависимость в pom файл. Spring про запуске начнет учитывать класс SecurityAutoConfiguration,
 * помеченный аннотацией @ConditionalOnClass(DefaultAuthenticationEventPublisher.class). Он импортирует
 * другие классы настройки при помощи аннотации @Import(class, class, class...). В том числе
 * static class DefaultConfigurerAdapter extends WebSecurityConfigurerAdapter.
 * На практике это выглядит как табличка с требованием ввести логин/пароль. Логин - user, пароль - будет
 * выводиться в логе при запуске приложения (генерируется в UserDetailsServiceAutoConfiguration.class)
 * HttpSecurity по умолчанию сконфигурируется следующим образом -
 *
 * http.authorizeRequest()
 *      .anyRequest().authenticated()
 *      .and().formLogin().and().httpBasic();
 *
 * Для того, чтобы запрос направлялся не в это страшненькое окошко, появляющееся по умолчанию, а на нашу страницу
 * логина, нужно внести следующие изменения -
 * http.authorizeRequest()
 *      .anyRequest().authenticated()
 *      .and().formLogin().loginPage("/login");
 *
 * Мы можем создать несколько классов, экстендящих WebSecurityConfigurerAdapter, если нужно нстроить различные типы
 * аут-и для разных url. В каждом из классов нужно указать помимо прочего приоритет аннотацией @Order. По умолчанию
 * у WebSecurityConfigurerAdapter @Order(100). Не должно быть двух классов с одиноковым order.
 *
 * Spring Security по умолчанию защищает от многих типов атак, но т.к. оно очень сильно кастомизируемо, программист может
 * случайно что-то нажать, и все сломается.
 * 1) Spring Security добавляет в response несколько хэдеров:
 *  - Cache-Control - отключает любое кеширование. Несмотря на то, что кэширование увеличивает производительность,
 *  оно так же позволяет злодеям видеть закешированные версии страниц даже после того, как пользователь разлогинился
 *  Однако кеширование можно испотзовать для url, не содержащих особо важной информации. Для этого можно использовать
 *  подобный код в контроллере ResponseEntity.ok().cacheControl(CacheControl.maxAge(30, TimeUnit.SECONDS)).body(...).
 *  Также кэширование можно включить в настройках HttpSecurity -
 *  http.headers().disable() - вообще отключает проверяющий хэдеры фильтр
 *  http.headers().defaultsDisabled() - отключает проверку хэдеров по умолчанию
 *  http.cacheControl().disable() - отключает конкретно cache-control
 *
 * б)
 *
 * Настройка SPA. Если есть formLogin() и требуется авторизация, то сначала появится та стремная форма для ввода логина
 * и пароля, а уже после этого мы попадем на настоящую страницу приложения.
 * Для настройки работы csrf - http.csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) -
 * передаем токен в куки и разрешаем javascript-коду фронта спарсить его (обычно браузер не позволяет таких вольностей).
 * Логаут - logout().logoutUrl("/api/auth/logout")
 * )
 *
 * Exceptions.
 */

package blogengine.security;